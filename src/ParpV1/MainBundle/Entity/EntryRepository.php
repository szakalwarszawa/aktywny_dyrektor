<?php

namespace ParpV1\MainBundle\Entity;

use Doctrine\ORM\EntityRepository;
use DateTime;

/**
 * EntryRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EntryRepository extends EntityRepository
{
    public function findNowaSekcjaTYLKOuzywaneWreorganizacji2016($sam)
    {
        $query = $this->createQueryBuilder('e')
                ->where('e.isImplemented = false')
                ->andWhere('e.samaccountname like :sam')
                ->andWhere("(e.info not like '' and e.info is not null)")
                ->setParameters(array('sam' => $sam))
                ->getQuery();
        $ret = $query->getResult();
        return $ret;
    }

    public function findByIsImplementedAndFromWhen($ids = "")
    {
        $where = "1 = 1";
        if ($ids != "") {
            $where = 'e.id IN ('.$ids.')';
        }
        $query = $this->createQueryBuilder('e')
                ->where('e.isImplemented = false')
                ->andWhere('e.fromWhen <= :date')
                ->andWhere('e.samaccountname != \'\'')
                ->andWhere($where)
                //->andWhere('e.memberOf = \'\' or e.memberOf is null')
                ->addOrderBy('e.id', 'ASC')
                ->setParameters(array('date' => new \DateTime()))
                ->getQuery();

        return $query->getResult();
    }

    public function getTempEntriesAsUsers($ldap)
    {
        $rets = array();
        $new = $this->findByIsImplementedAndFromWhen();
        foreach ($new as $e) {
            $ADUser = $ldap->getUserFromAD($e->getSamaccountname());

            if (count($ADUser) == 0) {
                $ret = array();
                $ret['id'] = $e->getId();
                $ret['samaccountname'] = $e->getSamaccountname();
                $ret['name'] = $e->getCn();
                $ret['initials'] = $e->getInitials();
                $ret['title'] = $e->getTitle();
                $ret['info'] = $e->getInfo();
                $ret['department'] = $e->getDepartment();
                $ret['description'] = "";
                $ret['division'] = $e->getDivision();
                $ret['lastlogon'] = "";
                $ret['manager'] = $e->getManager();
                $ret['thumbnailphoto'] = "";
                $ret['useraccountcontrol'] = "";

                $ret['accountexpires'] = "";
                $ret['isDisabled'] = $e->getIsDisabled();
                $ret['disableDescription'] = $e->getDisableDescription();
                $ret['accountExpires'] = "";
                $ret['email'] = "";
                $ret['cn'] = "";
                $ret['distinguishedname'] = "";
                $ret['memberOf'] = "";
                $ret['roles'] = "";
                $rets[] = $ret;
            }
        }
        return $rets;
    }
    public function findOsobyKtoreJuzPrzetworzylPrzyOdbieraniu($createdBy)
    {
        $query = $this->createQueryBuilder('e')
                ->select('e.samaccountname')
                ->where('e.isImplemented = 0')
                ->andWhere('e.createdBy in ( :data )')
                ->orderBy('e.id')
                ->setParameters(array('data' => $createdBy))
                ->getQuery();
        $ret = $query->getResult(\Doctrine\ORM\Query::HYDRATE_ARRAY);
        $data = [];
        foreach ($ret as $d) {
            if (!in_array($d['samaccountname'], $data)) {
                $data[] = $d['samaccountname'];
            }
        }
        return $data;
    }

    /**
     * Zwraca wszystkie zmiany jakie zaszły na koncie.
     *
     * @todo W przyszłości może być potrzebne pobieranie od daty.
     *
     * @return array
     */
    public function findZmianyNaUzytkownikach()
    {
        $queryBuilder = $this->createQueryBuilder('h');
        $queryBuilder
            ->select('h')
            ->orderBy('h.fromWhen', 'DESC');

        $query = $queryBuilder->getQuery();
        $results = $query->getResult();

        return $results;
    }

    /**
     * Zwraca datę ostatniej zmiany D/B
     *
     * @param  string $samaccountname
     *
     * @return Datetime|null
     */
    public function findZmianaDepartamentuUzytkownika($samaccountname)
    {
/*      Zapytaie testowe:
        SELECT
            e.samaccountname,
            e.fromWhen,
            e.department,
            e.distinguishedname,
            d.shortname
        FROM
            entry e
            left join departament d on d.name = e.department
        where
            e.department is not null
            and e.samaccountname = 'hubert_gorecki'
            and e.distinguishedname not like CONCAT('%OU=', d.shortname, '%')
        order by
            e.fromWhen desc
        limit
            1
*/
        $queryBuilder = $this->createQueryBuilder('z');
        $queryBuilder
            ->select('z.fromWhen as data_zmiany')
            ->leftJoin('ParpMainBundle:Departament', 'd')
            ->where('z.department is not null')
            ->andWhere('z.samaccountname = :samaccountname')
            ->andWhere('d.name = z.department')
            ->andWhere('d.nowaStruktura = 1')
            ->andWhere("z.distinguishedName not like CONCAT('%OU=',d.shortname,',%')")
            ->setParameters(array('samaccountname' => $samaccountname))
            ->orderBy('z.fromWhen', 'DESC')
            ->setMaxResults(1);

        $query = $queryBuilder->getQuery();
        $dataZmiany = $query->getResult();

        return $dataZmiany;
    }

    /**
     * Wyszukuje dokonane i oczekujące zmiany użytkownika.
     *
     * @param string $username
     * @param bool $groupByImplemented
     *
     * @return array
     */
    public function findUserChanges(string $username, bool $groupByImplemented = true): array
    {
        $queryBuilder = $this->createQueryBuilder('e');

        $queryBuilder
            ->select('e')
            ->where('e.samaccountname = :username')
            ->setParameter('username', $username)
        ;

        $result = $queryBuilder
            ->getQuery()
            ->getResult()
        ;

        $groupedResult = [];
        if ($groupByImplemented) {
            foreach ($result as $row) {
                if ($row->getIsImplemented()) {
                    $groupedResult['aktywne'][] = $row;
                    continue;
                }
                $groupedResult['nieaktywne'][] = $row;
            }

            return $groupedResult;
        }

        return $result;
    }

    /**
     * Znajduje oczekujące na implementację zmiany.
     *
     * @return array
     */
    public function findChangesToImplement()
    {
        $queryBuilder = $this->createQueryBuilder('e');

        $queryBuilder
            ->select('e')
            ->where('e.isImplemented = 0')
            ->andWhere('e.fromWhen <= :now')
            ->setParameter('now', new DateTime())
        ;

        $result = $queryBuilder
            ->getQuery()
            ->getResult()
        ;

        return $result;
    }

    /**
     * Odszukuje wpisy zmiany na podstawie wniosku z którego pochodzą.
     *
     * @param Wniosek $application
     *
     * @return array
     */
    public function findChangesToImplementByApplication(Wniosek $application)
    {
        $queryBuilder = $this->createQueryBuilder('e');

        $queryBuilder
            ->select('e')
            ->where('e.isImplemented = 0')
            ->andWhere('e.fromWhen <= :now')
            ->andWhere('e.wniosek = :applicationId')
            ->setParameter('now', new DateTime())
            ->setParameter('applicationId', $application->getId())
        ;

        $result = $queryBuilder
            ->getQuery()
            ->getResult()
        ;

        return $result;
    }
}
